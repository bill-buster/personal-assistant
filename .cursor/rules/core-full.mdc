---
description: Detailed conventions, examples, and patterns for the Personal Assistant codebase
globs: ["**/*.ts"]
alwaysApply: false
---

# Personal Assistant - Core Conventions (Full)

> **Note**: This is the detailed reference. For essential conventions, see `.cursor/rules/core-lite.mdc`.

## Type Patterns

### Use Zod Schemas for Validation

**Always use Zod v4 for runtime validation at all boundaries.**

#### Basic Schema Patterns

```typescript
// Define schema
export const TaskAddSchema = z.object({
    text: z.string().min(1),
    due: z.string().optional(),
    priority: z.enum(['low', 'medium', 'high']).optional(),
});

// Derive type from schema
export type TaskAddArgs = z.infer<typeof TaskAddSchema>;
```

#### Common Zod Patterns Used in This Project

```typescript
// String with validation
z.string().min(1)                    // Required non-empty string
z.string().optional()                // Optional string
z.string().default('')                // String with default value

// Numbers
z.number().int().min(0)              // Non-negative integer
z.number().int().min(1).max(100)      // Bounded integer
z.number().optional().default(0)      // Optional with default

// Arrays
z.array(z.string()).default([])      // Array with default empty
z.array(z.string()).min(1)            // Non-empty array

// Enums
z.enum(['low', 'medium', 'high'])     // String enum
z.enum(['low', 'medium', 'high']).optional()  // Optional enum

// Complex objects
z.object({
    required: z.string().min(1),
    optional: z.string().optional(),
    withDefault: z.number().default(0),
    nested: z.object({
        field: z.string(),
    }).optional(),
});
```

#### Validation with safeParse

```typescript
// Always use safeParse for validation (never throw)
const result = schema.safeParse(data);

if (!result.success) {
    return {
        ok: false,
        error: makeError('VALIDATION_ERROR', result.error.issues[0].message),
    };
}

// Use result.data (validated and typed)
const validated = result.data;
```

#### Register Schema in ToolSchemas

```typescript
// After defining schema, add to registry
export const ToolSchemas: Record<string, z.ZodTypeAny> = {
    // ... existing tools
    my_tool: MyToolSchema,
};
```

### Use Discriminated Unions for Results

```typescript
export type RouteResult =
    | RouteError
    | RouteToolCall
    | RouteReply;

// With type guards
export function isRouteError(result: RouteResult): result is RouteError {
    return 'error' in result;
}
```

### TypeScript Patterns

#### Discriminated Unions (Preferred Pattern)

```typescript
// Use discriminated unions for result types
export type ToolResult =
    | { ok: true; result: any; _debug?: DebugInfo | null }
    | { ok: false; error: ToolError; _debug?: DebugInfo | null };

// Type guards for runtime checks
export function isSuccess(result: ToolResult): result is { ok: true; result: any } {
    return result.ok === true;
}
```

#### Utility Types

```typescript
// Readonly for immutable data
export type Limits = Readonly<{
    maxReadSize: number;
    maxWriteSize: number;
}>;

// Optional fields
export interface Task {
    id: number;
    text: string;
    done_at?: string | null;  // Optional, can be null
    priority?: 'low' | 'medium' | 'high' | null;
}

// Record types for maps
export const ToolSchemas: Record<string, z.ZodTypeAny> = {
    // ...
};
```

#### Type Inference from Zod

```typescript
// Always derive types from Zod schemas
export const MySchema = z.object({ /* ... */ });
export type MyType = z.infer<typeof MySchema>;  // ✅ Preferred

// Not: manually defining types that duplicate schema
// type MyType = { /* ... */ };  // ❌ Avoid duplication
```

### Structured Error Objects

```typescript
export interface ToolError {
    code: string;    // e.g., 'EXEC_ERROR', 'VALIDATION_ERROR'
    message: string;
    details?: any;
}

// Create errors with makeError helper
return {
    ok: false,
    error: makeError('EXEC_ERROR', `Failed to read file: ${err.message}`),
};
```

## Function Documentation

Use JSDoc for all exported functions:

```typescript
/**
 * Handle remember tool.
 * @param args - Tool arguments containing text.
 * @param context - Execution context.
 * @returns Result object with ok, result, error, debug.
 */
export function handleRemember(args: RememberArgs, context: ExecutorContext): ToolResult {
    // ...
}
```

## Code Style

- Use `const` by default, `let` only when reassignment needed
- Prefer early returns to reduce nesting
- Use optional chaining (`?.`) and nullish coalescing (`??`)
- Prefix unused parameters with underscore: `(_unused, used) => {}`
- Empty catch blocks are allowed: `catch { }`
- Console logging is allowed (no-console: off)

## File Naming

- Source files: `snake_case.ts` (e.g., `memory_tools.ts`, `tool_registry.ts`)
- Test files: `*.test.ts` colocated with source
- Index files: `index.ts` for barrel exports

## Async Patterns

Always use async/await, never raw Promises:

```typescript
// ✅ Good
async function fetchData(): Promise<Data> {
    const result = await provider.complete(prompt);
    return result.data;
}

// ❌ Bad - raw Promise chains
function fetchData(): Promise<Data> {
    return provider.complete(prompt).then(r => r.data);
}
```

Handle async errors with try/catch:

```typescript
async function safeOperation(): Promise<ToolResult> {
    try {
        const data = await riskyAsyncCall();
        return { ok: true, result: data };
    } catch (err: any) {
        return { ok: false, error: makeError('EXEC_ERROR', err.message) };
    }
}
```

## Configuration Priority

Environment variables override config files:

```typescript
// Priority order (highest to lowest):
// 1. Environment variables (GROQ_API_KEY, ASSISTANT_DATA_DIR)
// 2. Config file (~/.assistant/config.json)
// 3. Hardcoded defaults

const apiKey = process.env.GROQ_API_KEY || config.apiKeys?.groq || null;
```

## Logging Conventions

Use console methods directly (no-console is off):

**Critical**: Debug logs must go to stderr, not stdout. stdout is reserved for actual command output (especially JSON).

```typescript
// Verbose/debug output (only when --verbose flag) - use stderr
if (verbose) console.error('[Verbose] Processing:', input);

// Errors always go to stderr
console.error('[Error] Failed to connect:', err.message);

// Debug/trace logs - use stderr to avoid corrupting stdout
console.error(`[Router] Matched tool: ${toolName}`);
console.error(`[Executor] Running: ${toolName}`);

// ✅ Good: stdout only for actual command output
if (outputFormat === 'json') {
    console.log(JSON.stringify(result));  // OK: actual output
}

// ❌ Bad: debug logs to stdout (breaks JSON parsing)
console.log('[Debug] Processing:', input);  // NEVER in code paths that output JSON
```

**Rule**: Never `console.log` in code paths that output JSON. Log to stderr instead.

## Common Helpers

Use helpers from `src/core/`:

```typescript
import { 
    makeError,      // Create structured ToolError
    makeDebug,      // Create DebugInfo object
    nowMs,          // Current timestamp in ms
    makeToolCall,   // Create ToolCall object
    parseArgs,      // Parse CLI arguments
} from '../core';
```

## Handling Stuck Operations

**If a command or file read seems stuck:**

1. **Check timeouts**: Most operations have built-in timeouts (git: 10s, LLM: 60s, fetch: 6s)
2. **If command hangs**: Check with `ps aux | grep <command>` or add `timeout` wrapper
3. **If file read fails**: Check existence (`ls`), permissions (`stat`), or try `cat` command
4. **If no response**: Check exit code (`echo $?`), check stderr, verify command isn't waiting for input

**When to give up:**
- Operation timed out 3+ times
- Permission denied (may need user intervention)
- Error unclear after 2-3 attempts

**See `.cursor/rules/debugging.mdc` for detailed troubleshooting patterns.**

## Related Rules

- **Git Workflow**: See `.cursor/rules/git.mdc` for commit policy and workflow (REQUIRED)
- **Error Handling**: See `.cursor/rules/errors.mdc` for error patterns and error codes
- **Performance**: See `.cursor/rules/performance.mdc` for optimization patterns
- **Security**: See `.cursor/rules/security.mdc` for security patterns
- **Tools**: See `.cursor/rules/tools.mdc` for tool implementation patterns
- **Test Policy**: See `.cursor/rules/test_policy.mdc` for when to run tests
- **Testing**: See `.cursor/rules/testing.mdc` for test-writing patterns
- **Research Policy**: See `.cursor/rules/research_policy.mdc` for when to use web research vs codebase knowledge
