---
description: Code review patterns and quality checks
globs: []
alwaysApply: false
---

# Code Review Patterns

## Review Checklist

Before approving code, verify:

### Functionality
- [ ] Code does what it claims to do
- [ ] Edge cases are handled
- [ ] Error cases are handled
- [ ] No obvious bugs

### Security
- [ ] Input validation (Zod schemas)
- [ ] Path validation (no traversal, no absolute paths)
- [ ] Command validation (allowlist)
- [ ] No secrets in logs/errors
- [ ] Permission checks enforced

### Performance
- [ ] No obvious performance issues
- [ ] Caching used where appropriate
- [ ] No unnecessary operations
- [ ] Large data handled efficiently (streaming)

### Code Quality
- [ ] Follows project conventions
- [ ] TypeScript types are correct
- [ ] No unused code
- [ ] Functions are focused (single responsibility)
- [ ] Naming is clear

### Testing
- [ ] Tests cover new functionality
- [ ] Tests cover error cases
- [ ] Tests are isolated (temp directories)
- [ ] Test names are descriptive

### Documentation
- [ ] JSDoc on exported functions
- [ ] Complex logic has comments
- [ ] User-facing features documented
- [ ] Configuration options documented

## Common Issues to Look For

### Security Issues

```typescript
// ❌ Path traversal vulnerability
const file = path.join(userInput, 'data.json'); // userInput could be '../../etc/passwd'

// ✅ Safe path resolution
const file = context.paths.resolveAllowed(userInput, 'read');

// ❌ Shell injection
exec(`ls ${userInput}`); // userInput could be '; rm -rf /'

// ✅ Safe command execution
context.commands.runAllowed('ls', [userInput]);

// ❌ Secrets in logs
console.log(`API key: ${apiKey}`);

// ✅ Sanitized logs
console.log('[Info] API key configured');
```

### Performance Issues

```typescript
// ❌ Synchronous file I/O in async context
const data = fs.readFileSync(largeFile);

// ✅ Async file I/O
const data = await fs.promises.readFile(largeFile);

// ❌ Sequential operations
for (const item of items) {
    await process(item);
}

// ✅ Parallel operations
await Promise.all(items.map(item => process(item)));

// ❌ Regex compiled in loop
for (const input of inputs) {
    const match = input.match(/pattern/); // Recompiled each time
}

// ✅ Pre-compiled regex
const RE_PATTERN = /pattern/;
for (const input of inputs) {
    const match = input.match(RE_PATTERN);
}
```

### Code Quality Issues

```typescript
// ❌ Any types
function process(data: any): any {
    return data.value;
}

// ✅ Proper types
function process<T extends { value: string }>(data: T): string {
    return data.value;
}

// ❌ Magic numbers
if (text.length > 100) { }

// ✅ Named constants
const MAX_TEXT_LENGTH = 100;
if (text.length > MAX_TEXT_LENGTH) { }

// ❌ Deep nesting
if (condition1) {
    if (condition2) {
        if (condition3) {
            return result;
        }
    }
}

// ✅ Early returns
if (!condition1) return null;
if (!condition2) return null;
if (!condition3) return null;
return result;
```

### Error Handling Issues

```typescript
// ❌ Throwing errors
throw new Error('Something went wrong');

// ✅ Return structured errors
return {
    ok: false,
    error: makeError('EXEC_ERROR', 'Something went wrong'),
};

// ❌ Generic error messages
makeError('EXEC_ERROR', 'Error');

// ✅ Specific error messages
makeError('DENIED_PATH_ALLOWLIST', `Path '${path}' is not allowed`);

// ❌ Losing error context
catch (err) {
    return { ok: false, error: makeError('EXEC_ERROR', 'Failed') };
}

// ✅ Preserve context
catch (err: any) {
    return {
        ok: false,
        error: makeError('EXEC_ERROR', `Failed: ${err.message}`, { context }),
    };
}
```

## Review Patterns by File Type

### Tool Handlers

Check:
- [ ] Uses Zod schema for validation
- [ ] Returns structured errors (never throws)
- [ ] Uses context capabilities (paths, commands)
- [ ] Includes debug info
- [ ] Handles edge cases (empty input, max size, etc.)

```typescript
// ✅ Good tool handler pattern
export function handleTool(args: ToolArgs, context: ExecutorContext): ToolResult {
    const { start } = context;
    
    // Validate
    const validation = validateArgs(args);
    if (!validation.ok) {
        return {
            ok: false,
            error: makeError('VALIDATION_ERROR', validation.message),
            _debug: makeDebug({ path: 'tool_json', start, /* ... */ }),
        };
    }
    
    // Execute
    try {
        const result = execute(args, context);
        return {
            ok: true,
            result,
            _debug: makeDebug({ path: 'tool_json', start, /* ... */ }),
        };
    } catch (err: any) {
        return {
            ok: false,
            error: makeError('EXEC_ERROR', err.message),
            _debug: makeDebug({ path: 'tool_json', start, /* ... */ }),
        };
    }
}
```

### Parsers

Check:
- [ ] Pre-compiled regex patterns
- [ ] Returns consistent ParseResult structure
- [ ] Handles null/empty input
- [ ] Clear error messages

```typescript
// ✅ Good parser pattern
const RE_PATTERN = /^command:\s+(.+)$/i;

export function parseCommand(input: string): ParseResult | null {
    if (!input || !input.trim()) return null;
    
    const match = input.match(RE_PATTERN);
    if (!match) return null;
    
    const [, arg] = match;
    if (!arg.trim()) {
        return { error: 'Command argument required' };
    }
    
    return { tool: { name: 'tool_name', args: { arg } } };
}
```

### Providers

Check:
- [ ] Never throws (returns structured errors)
- [ ] Handles network errors
- [ ] Implements retry logic for transient errors
- [ ] Respects rate limits
- [ ] Tracks token usage

```typescript
// ✅ Good provider pattern
async chat(request: ChatRequest): Promise<ChatResponse> {
    try {
        const response = await fetch(this.endpoint, options);
        
        if (!response.ok) {
            return {
                ok: false,
                error: `API error ${response.status}`,
            };
        }
        
        const data = await response.json();
        return this.parseResponse(data);
    } catch (err: any) {
        return {
            ok: false,
            error: `Network error: ${err.message}`,
        };
    }
}
```

## Review Comments

Use clear, actionable review comments:

```typescript
// ✅ Good review comment
// Consider using context.paths.resolveAllowed() here for path validation
// See .cursor/rules/security.mdc for path security patterns

// ❌ Bad review comment
// This looks wrong
```

## Approval Criteria

Approve code when:
- ✅ All checklist items pass
- ✅ Code follows project conventions
- ✅ Tests pass and cover new code
- ✅ Documentation is updated
- ✅ No security issues
- ✅ Performance is acceptable

Request changes when:
- ❌ Security issues found
- ❌ Tests missing or failing
- ❌ Code doesn't follow conventions
- ❌ Documentation missing
- ❌ Performance issues
- ❌ Code quality issues (naming, structure)

## Integration with Other Rules

- **Security Rule**: See `.cursor/rules/security.mdc` for security review checklist
- **Testing Rule**: See `.cursor/rules/testing.mdc` for test review patterns
- **Tools Rule**: See `.cursor/rules/tools.mdc` for tool handler review patterns
- **Errors Rule**: See `.cursor/rules/errors.mdc` for error handling review patterns

## Automated Review Tools

### Running Reviews

Use the review script to systematically review code:

```bash
# Review entire codebase
npm run review

# Review specific directory
npm run review src/tools/

# Review single file
npm run review src/tools/file_tools.ts
```

### Auto-Fixing Issues

Some issues can be auto-fixed:

```bash
npm run review:fix
```

**Note**: Review changes before committing!

### Review Scripts

- **Location**: `src/scripts/code_review.ts` (executable tool)
- **Purpose**: Systematic code review, scoring, issue detection
- **Output**: Score (0-100) + categorized issues + critical issues list

See `docs/CONTINUOUS_IMPROVEMENT.md` for complete workflow.

## Best Practices

**Scripts vs Rules**:
- ✅ **Scripts** (`src/scripts/`) = Executable tools (run via CLI)
- ✅ **Rules** (`.cursor/rules/`) = AI guidance patterns (read by Cursor)

This follows industry best practices (like ESLint/Prettier separation).

See `docs/CODE_REVIEW_BEST_PRACTICES.md` for details.
