---
description: USE WHEN creating or editing Cursor slash commands, chaining workflows, or defining multi-step quality gates.
globs: []
alwaysApply: false
---

# Workflow & Command-Chaining Rules

## Principles
- Prefer a single composite command over "run 6 commands manually."
- Make workflows idempotent: safe to re-run after partial completion.
- Use explicit quality gates: tests + review must be green before commit.
- Keep state in files (e.g., checklist or HANDOFF logs), not in memory.

## Composite command structure
- Preflight: read checklist + identify files touched
- Implement: small steps with clear outputs
- Test: narrow → broad
- Review: automated → manual
- Fix loop: fix → re-test → re-review (repeat until green)
- Commit + summary: always end with "what changed + tests run"

## Logging
- Use `[STEP X/Y]` markers.
- Record test commands run verbatim and their results.

## Auto-Commit Policy (For Composite Workflows)

**In composite commands that implement features end-to-end, the agent SHOULD commit automatically** when:
- ✅ Code changes are complete and tested
- ✅ All preflight checks pass
- ✅ Changes follow project conventions
- ✅ Commit message follows conventional commit format

**Workflow steps (typically Steps 15-16 in a composite command):**

```bash
# Step 15: Stage and commit (if checks pass)
git add <modified-files>
npm run preflight
git commit -m "<type>(<scope>): <subject>"

# Step 16: Report what was committed
# Report commit hash and message to user
```

**The agent MUST NOT commit** when:
- ❌ User explicitly asks not to commit
- ❌ Changes are incomplete or experimental
- ❌ Preflight checks fail
- ❌ User needs to review changes first

**Note**: This policy applies to composite workflows (e.g., `/implement_and_review_tool`). For normal coding sessions, commits are user-initiated.
