---
description: Intent routing and parser patterns
globs: ["src/app/router.ts", "src/parsers/**/*.ts"]
alwaysApply: false
---

# Routing & Parser Patterns

## Multi-Stage Routing Strategy

The router uses a cascading strategy for efficiency:

```
1. Regex Fast Paths     → Pre-compiled patterns for common commands
2. Heuristic Parser     → Pattern matching with NLP rules  
3. Task/Memory Parsers  → Domain-specific command parsing
4. LLM Fallback         → Only when heuristics fail
```

## Regex Fast Paths

Pre-compile patterns at module level for V8 optimization:

```typescript
// Pre-compiled regex patterns (module level)
const RE_REMEMBER = /^remember:\s+([\s\S]+)$/i;
const RE_RECALL = /^recall:\s+([\s\S]+)$/i;
const RE_TIME = /^(?:what time is it|current time|time now|time|date)$/i;

// In route function
if (routerConfig.enableRegex !== false) {
    const rememberMatch = body.match(RE_REMEMBER);
    if (rememberMatch && isToolAllowed('remember')) {
        return success(intent, 'remember', { text: rememberMatch[1] }, 'regex_fast_path', start);
    }
}
```

## Route Result Types

Use discriminated unions for type-safe results:

```typescript
export type RouteResult =
    | RouteError
    | RouteToolCall
    | RouteReply;

export interface RouteToolCall {
    version: 1;
    intent: string;
    mode: 'tool_call';
    tool_call: ToolCall;
    reply: null;
    usage?: TokenUsage | null;
    _debug: DebugInfo;
}

export interface RouteReply {
    version: 1;
    intent: string;
    mode: 'reply';
    tool_call: null;
    reply: { instruction: string; content: string; prompt: string; };
    usage?: TokenUsage | null;
    _debug: DebugInfo;
}
```

## Parser Return Pattern

Parsers return a consistent structure:

```typescript
interface ParseResult {
    tool?: { name: string; args: Record<string, any> };
    error?: string;
}

export function parseTaskCommand(input: string): ParseResult | null {
    const match = input.match(/^task\s+(add|list|done)\s*(.*)$/i);
    if (!match) return null;
    
    const [, action, rest] = match;
    
    switch (action.toLowerCase()) {
        case 'add':
            if (!rest.trim()) {
                return { error: 'Task text required' };
            }
            return { tool: { name: 'task_add', args: { text: rest.trim() } } };
        // ...
    }
}
```

## Agent Permission Checks

Check permissions before returning tool calls:

```typescript
const isToolAllowed = (toolName: string): boolean => {
    return !agent || agent.tools.includes(toolName);
};

// In routing logic
const heuristicCommand = parseHeuristicCommand(body);
if (heuristicCommand?.tool) {
    if (!isToolAllowed(heuristicCommand.tool.name)) {
        // Skip to LLM fallback instead of returning
        if (verbose) console.log(`[Verbose] Skipping ${heuristicCommand.tool.name}, no permission`);
    } else {
        return makeToolCallResult(heuristicCommand.tool);
    }
}
```

## LLM Fallback

Only call LLM when heuristics fail:

```typescript
if (injectedProvider) {
    // Filter tools based on agent permissions
    const allowedTools: Record<string, ToolSpec> = {};
    for (const name of currentAgent.tools) {
        if (schemas[name]) {
            allowedTools[name] = schemas[name];
        }
    }
    
    const res = await provider.complete(
        body, 
        allowedTools,     // Only allowed tools
        history, 
        verbose, 
        currentAgent.systemPrompt,
        { toolFormat: routerConfig.toolFormat }
    );
    
    if (res.ok && res.toolCall) {
        // Double-check LLM didn't hallucinate an unauthorized tool
        if (!isToolAllowed(res.toolCall.tool_name)) {
            return { error: `Tool '${res.toolCall.tool_name}' not allowed`, code: 2 };
        }
        return makeToolCallResult(res.toolCall);
    }
}
```

## Router Configuration

```typescript
export interface RouterConfig {
    enableRegex?: boolean;              // Default: true
    toolFormat?: 'standard' | 'compact'; // Default: 'compact'
    strategy?: 'single_step' | 'two_step';
    toolSchemas?: Record<string, ToolSpec>;
}
```

## Success Helper

Standardize successful tool call returns:

```typescript
function success(
    intent: string, 
    tool: string, 
    args: any, 
    path: string, 
    start: number
): RouteToolCall {
    return {
        version: 1 as const,
        intent,
        mode: 'tool_call' as const,
        tool_call: makeToolCall(tool, args),
        reply: null,
        _debug: makeDebug({ 
            path, 
            start, 
            model: null, 
            memory_read: false, 
            memory_write: false 
        })
    };
}
```

## Adding a New Regex Pattern

When adding fast-path regex:

### 1. Define Pattern at Module Level

```typescript
// Pre-compiled for V8 optimization (top of router.ts)
const RE_MY_COMMAND = /^my command:\s+([\s\S]+)$/i;
```

### 2. Add Match in route()

```typescript
// In the regex fast paths section
if (routerConfig.enableRegex !== false) {
    // ... existing patterns ...
    
    const myMatch = body.match(RE_MY_COMMAND);
    if (myMatch && isToolAllowed('my_tool')) {
        return success(intent, 'my_tool', { text: myMatch[1] }, 'regex_fast_path', start);
    }
}
```

### 3. Pattern Guidelines

```typescript
// ✅ Good patterns
/^remember:\s+([\s\S]+)$/i           // Clear trigger, captures content
/^(?:time|date|what time)$/i         // Multiple synonyms
/^git\s+(status|diff|log)$/i         // Subcommand matching

// ❌ Avoid
/^.*remember.*$/i                     // Too greedy, matches too much
/^r$/i                                // Too short, false positives
```

## Adding a New Heuristic Parser

For more complex patterns, add a parser:

### 1. Create Parser File

```typescript
// src/parsers/my_parser.ts
export function parseMyCommand(input: string): ParseResult | null {
    const match = input.match(/^my (\w+) command (.+)$/i);
    if (!match) return null;
    
    const [, action, target] = match;
    
    switch (action.toLowerCase()) {
        case 'start':
            return { tool: { name: 'my_start', args: { target } } };
        case 'stop':
            return { tool: { name: 'my_stop', args: { target } } };
        default:
            return { error: `Unknown action: ${action}` };
    }
}
```

### 2. Export from Parsers Index

```typescript
// src/parsers/index.ts
export { parseMyCommand } from './my_parser';
```

### 3. Add to Router

```typescript
// In route(), after existing parsers
const myCommand = parseMyCommand(body);
if (myCommand && myCommand.error) {
    return { error: myCommand.error, code: 2 };
}
if (myCommand && myCommand.tool) {
    if (!isToolAllowed(myCommand.tool.name)) {
        // Skip to LLM fallback
    } else {
        return makeToolCallResult(myCommand.tool);
    }
}
```

## Parser Precedence

Parsers are checked in this order:

1. **Regex fast paths** (fastest, most specific)
2. **Heuristic parser** (general patterns)
3. **Task parser** (task-specific commands)
4. **Memory parser** (memory-specific commands)
5. **LLM fallback** (slowest, most flexible)

Earlier matches win. Put more specific patterns first.
