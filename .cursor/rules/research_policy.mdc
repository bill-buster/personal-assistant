---
description: When to use web research vs codebase knowledge for best practices and solutions
globs: ["**/*"]
alwaysApply: true
---

# Research Policy

## When to Use Web Research

**Use web search/research when:**

1. **New Technologies/Frameworks**
   - Adding a new library or tool not in codebase
   - Learning API patterns for external services
   - Checking current version compatibility

2. **Time-Sensitive Information**
   - Security vulnerabilities or CVEs
   - Breaking changes in dependencies
   - Current best practices that change frequently

3. **External API Documentation**
   - Third-party service APIs (GitHub, Slack, etc.)
   - LLM provider API changes
   - Standard protocols (HTTP, WebSocket, etc.)

4. **Performance Optimization**
   - Node.js performance best practices
   - TypeScript compiler optimizations
   - V8 engine specifics

5. **Error Messages from External Services**
   - API error codes you haven't seen
   - Service-specific error patterns
   - Rate limiting or quota issues

6. **Industry Standards**
   - Security standards (OWASP, CWE)
   - Testing best practices (Jest, Vitest patterns)
   - Git workflow standards

## When NOT to Use Research

**Don't use research when:**

1. **Codebase-Specific Patterns**
   - File structure conventions (already in `core.mdc`)
   - Import patterns (already documented)
   - Error handling patterns (already in `errors.mdc`)

2. **Established Patterns in Codebase**
   - Tool handler signatures (see `tools.mdc`)
   - Test structure (see `testing.mdc`)
   - Security patterns (see `security.mdc`)

3. **Simple Syntax Questions**
   - TypeScript syntax
   - Node.js built-in APIs
   - Zod schema patterns

4. **Internal Architecture**
   - How routing works (see `routing.mdc`)
   - How executor works (see codebase)
   - How caching works (see `CACHING.md`)

5. **Quick Fixes**
   - Typos or simple bugs
   - Formatting issues
   - Missing imports

## Decision Tree

**Before researching, ask:**

1. **Is this documented in the codebase?**
   - Check `.cursor/rules/*.mdc` files
   - Check `docs/*.md` files
   - Check existing code patterns
   - → If yes: Use codebase knowledge, don't research

2. **Is this a well-established pattern?**
   - TypeScript/Node.js conventions
   - Zod validation patterns
   - File I/O patterns
   - → If yes: Use codebase patterns, don't research

3. **Is this external/new?**
   - New library integration
   - External API usage
   - Current security advisories
   - → If yes: Research is appropriate

4. **Is this time-sensitive?**
   - Breaking changes
   - Security issues
   - Version compatibility
   - → If yes: Research is appropriate

## Research Best Practices

**When researching:**

1. **Be specific**: Search for exact error messages, API names, version numbers
2. **Check dates**: Prefer recent information (last 1-2 years)
3. **Verify sources**: Prefer official docs, GitHub issues, Stack Overflow
4. **Cross-reference**: If multiple sources conflict, check official docs
5. **Document findings**: If research reveals important patterns, consider adding to codebase docs

**After researching:**

1. **Verify against codebase**: Does the research align with existing patterns?
2. **Check for conflicts**: Does it contradict existing rules?
3. **Consider documenting**: If it's a recurring pattern, add to appropriate `.mdc` file

## Examples

### ✅ Good Use of Research

**Scenario**: Adding a new LLM provider (Anthropic)

**Research needed**: 
- Anthropic API documentation
- Current SDK patterns
- Rate limiting best practices
- Error handling patterns

**Why**: New external service, not in codebase

### ❌ Unnecessary Research

**Scenario**: Adding error handling to a tool

**Research NOT needed**:
- Error handling patterns (already in `errors.mdc`)
- Tool result structure (already in `tools.mdc`)
- Error code conventions (already documented)

**Why**: Well-established patterns in codebase

### ✅ Good Use of Research

**Scenario**: Optimizing test performance

**Research needed**:
- Node.js spawnSync performance
- Parallel test execution patterns
- Test caching strategies

**Why**: Performance optimization, may have new best practices

### ❌ Unnecessary Research

**Scenario**: Writing a new tool handler

**Research NOT needed**:
- Tool handler signature (see `tools.mdc`)
- ExecutorContext usage (see codebase)
- Result structure (see `types.ts`)

**Why**: All patterns documented in codebase

## Cost-Benefit Analysis

### Pros of Research

✅ **Up-to-date information**: Current best practices, latest APIs  
✅ **External validation**: Confirms approach aligns with community  
✅ **Specific solutions**: Can find exact solutions to problems  
✅ **Security awareness**: Latest vulnerabilities and fixes  
✅ **Performance insights**: New optimization techniques

### Cons of Research

❌ **Slower**: API calls add latency (2-5 seconds per search)  
❌ **May conflict**: External patterns may not match codebase conventions  
❌ **Cost**: Uses API quota (if using paid services)  
❌ **Overhead**: May introduce patterns that need refactoring later  
❌ **Unnecessary**: Most questions can be answered from codebase

## Quick Reference

```bash
# Check codebase first
grep -r "pattern" .cursor/rules/
cat docs/*.md | grep "topic"

# Then research if:
# - Not found in codebase
# - External API/service
# - Security/performance critical
# - Time-sensitive information
```

## Default Behavior

**Default to codebase knowledge first.** Only research if:
1. Information not found in codebase
2. External service/API question
3. Time-sensitive (security, breaking changes)
4. Performance optimization (may have new techniques)

**When in doubt**: Check codebase rules/docs first, then research if needed.
