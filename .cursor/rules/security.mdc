---
description: Security patterns and permission enforcement
globs: ["src/core/executor.ts", "src/tools/file_tools.ts", "src/tools/cmd_tools.ts"]
alwaysApply: false
---

# Security Patterns

## Fail-Closed Security Model

All security checks fail closed (deny by default):

```typescript
// If no agent provided, only safe tools are allowed
if (!this.agent) {
    const SAFE_TOOLS = ['calculate', 'get_time', 'delegate_to_coder'];
    if (!SAFE_TOOLS.includes(toolName)) {
        return {
            ok: false,
            error: makeError(ErrorCode.DENIED_AGENT_TOOLSET, 
                `Permission denied: tool '${toolName}' requires agent context`),
        };
    }
}
```

## Path Validation

Always validate paths before operations:

```typescript
// Use capability API (throws on invalid paths)
const resolved = context.paths.resolveAllowed(requestedPath, 'read');

// Or manual validation
private safeResolve(relPath: string): string | null {
    if (!relPath || typeof relPath !== 'string') return null;
    if (path.isAbsolute(relPath)) return null;        // No absolute paths
    if (relPath.includes('..')) return null;           // No traversal
    
    const resolved = path.resolve(this.baseDir, relPath);
    
    // Must be under baseDir
    if (!resolved.startsWith(this.baseDir + path.sep)) return null;
    
    // Canonicalize to prevent symlink bypass
    try {
        const canonical = fs.realpathSync(resolved);
        if (!canonical.startsWith(this.baseDir + path.sep)) return null;
        return canonical;
    } catch {
        // For new files, verify parent is under baseDir
        const parentDir = path.dirname(resolved);
        const canonicalParent = fs.realpathSync(parentDir);
        if (!canonicalParent.startsWith(this.baseDir + path.sep)) return null;
        return resolved;
    }
}
```

## Hardcoded Security Blocks

Always block sensitive paths regardless of permissions:

```typescript
private isAllowedPath(targetPath: string): boolean {
    const relPath = path.relative(this.baseDir, targetPath);
    const parts = relPath.split(path.sep);
    
    // Case-insensitive blocks (prevents bypass on macOS/Windows)
    if (parts.some(p => {
        const lower = p.toLowerCase();
        return lower === '.git' || 
               lower === '.env' || 
               lower === 'node_modules';
    })) return false;
    
    // Then check allowlist...
}
```

## Command Allowlist

Only execute explicitly allowed commands:

```typescript
const allowedCommands = this.permissions.allow_commands;
if (!allowedCommands.includes(cmd)) {
    return {
        ok: false,
        error: `Command '${cmd}' is not allowed`,
        errorCode: ErrorCode.DENIED_COMMAND_ALLOWLIST,
    };
}

// Validate command-specific flags
if (cmd === 'ls') {
    const allowedChars = new Set(['a', 'l', 'R', '1', 'h', 'A', 'F']);
    for (const arg of args) {
        if (arg.startsWith('-')) {
            for (let i = 1; i < arg.length; i++) {
                if (!allowedChars.has(arg[i])) {
                    return { ok: false, error: `Unsafe flag: ${arg}` };
                }
            }
        }
    }
}
```

## Permissions Configuration

Load from `permissions.json`:

```typescript
export const PermissionsSchema = z.object({
    version: z.number().optional(),
    allow_paths: z.array(z.string()).default([]),
    allow_commands: z.array(z.string()).default([]),
    require_confirmation_for: z.array(z.string()).default([]),
    deny_tools: z.array(z.string()).default([])
});
```

## Agent Tool Restrictions

Enforce agent-specific tool access:

```typescript
if (this.agent && this.agent.name !== 'System') {
    if (!this.agent.tools.includes(toolName)) {
        return {
            ok: false,
            error: makeError(DENIED_AGENT_TOOLSET, 
                `Agent '${this.agent.name}' cannot use tool '${toolName}'`),
        };
    }
}
```

## Confirmation Requirements

Require explicit confirmation for sensitive operations:

```typescript
if (context.requiresConfirmation(toolName) && !args.confirm) {
    return {
        ok: false,
        error: makeError('CONFIRMATION_REQUIRED', 
            `Tool '${toolName}' requires confirmation. Pass confirm: true.`),
    };
}
```

## Size Limits

Enforce file operation limits:

```typescript
export type Limits = Readonly<{
    maxReadSize: number;   // e.g., 65536 bytes
    maxWriteSize: number;  // e.g., 65536 bytes
}>;

// In file tools
if (content.length > context.limits.maxWriteSize) {
    return {
        ok: false,
        error: makeError('EXEC_ERROR', 
            `Content exceeds max write size of ${context.limits.maxWriteSize} bytes`),
    };
}
```

## Error Codes

Use consistent error codes:

```typescript
export const ErrorCode = {
    VALIDATION_ERROR: 'VALIDATION_ERROR',
    MISSING_ARGUMENT: 'MISSING_ARGUMENT',
    INVALID_ARGUMENT: 'INVALID_ARGUMENT',
    EXEC_ERROR: 'EXEC_ERROR',
    PARSE_ERROR: 'PARSE_ERROR',
    UNKNOWN_TOOL: 'UNKNOWN_TOOL',
    DENIED_PATH_ALLOWLIST: 'DENIED_PATH_ALLOWLIST',
    DENIED_COMMAND_ALLOWLIST: 'DENIED_COMMAND_ALLOWLIST',
    DENIED_TOOL_BLOCKLIST: 'DENIED_TOOL_BLOCKLIST',
    DENIED_AGENT_TOOLSET: 'DENIED_AGENT_TOOLSET',
    CONFIRMATION_REQUIRED: 'CONFIRMATION_REQUIRED',
};
```

## Audit Logging

All tool executions are logged to audit trail:

```typescript
private logAudit(toolName: string, args: any, result: ToolResult): void {
    if (!this.auditEnabled) return;
    
    const entry = {
        ts: new Date().toISOString(),
        tool: toolName,
        args: this.sanitizeArgs(args),  // Remove sensitive data
        ok: result.ok,
        error: result.error?.message || null,
        duration_ms: result._debug?.duration_ms || null
    };
    
    fs.appendFileSync(this.auditPath, JSON.stringify(entry) + '\n');
}
```

Audit log location: `~/.assistant/data/audit.jsonl`

### Sanitize Sensitive Data

Never log secrets or large content:

```typescript
private sanitizeArgs(args: any): any {
    if (!args || typeof args !== 'object') return args;
    
    const sanitized = { ...args };
    
    // Truncate large content
    if (sanitized.content?.length > 100) {
        sanitized.content = sanitized.content.substring(0, 100) + '...[truncated]';
    }
    
    // Redact sensitive fields
    if (sanitized.password) sanitized.password = '[REDACTED]';
    if (sanitized.apiKey) sanitized.apiKey = '[REDACTED]';
    
    return sanitized;
}
```

## Security Review Checklist for New Tools

Before merging a new tool, verify:

### Input Validation
- [ ] All args validated via Zod schema
- [ ] String inputs have reasonable max lengths
- [ ] Numeric inputs have min/max bounds
- [ ] No raw user input passed to shell/eval

### Path Security
- [ ] Uses `context.paths.resolveAllowed()` for all file paths
- [ ] No absolute path construction from user input
- [ ] No path traversal possible (`..`)
- [ ] Respects `allow_paths` from permissions.json

### Command Security
- [ ] Uses `context.commands.runAllowed()` for shell commands
- [ ] No shell injection possible
- [ ] Command and args validated separately
- [ ] Respects `allow_commands` from permissions.json

### Data Security
- [ ] No secrets logged or returned in results
- [ ] Sensitive data sanitized in audit logs
- [ ] No PII exposed in error messages
- [ ] File size limits enforced

### Permission Model
- [ ] Tool added to appropriate agent toolsets only
- [ ] Confirmation required for destructive operations
- [ ] Respects `deny_tools` blocklist
- [ ] Fails closed on permission errors

## Security Anti-Patterns

### ❌ Never Do This

```typescript
// Direct shell execution
exec(userInput);  // NEVER

// Path construction from user input  
const file = `/etc/${args.filename}`;  // NEVER

// Eval of user content
eval(args.expression);  // NEVER

// Secrets in error messages
throw new Error(`Auth failed for key: ${apiKey}`);  // NEVER
```

### ✅ Safe Alternatives

```typescript
// Validated command execution
const result = context.commands.runAllowed('ls', [args.path]);

// Safe path resolution
const file = context.paths.resolveAllowed(args.filename, 'read');

// Safe expression evaluation (limited operators)
const result = safeEval(args.expression);  // Custom parser

// Generic error messages
throw new Error('Authentication failed');
```

## Related Rules

- **Error Handling**: See `.cursor/rules/errors.mdc` for error code patterns
- **Code Review**: See `.cursor/rules/code_review.mdc` for security review checklist
- **Tools**: See `.cursor/rules/tools.mdc` for tool security patterns
