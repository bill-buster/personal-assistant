---
description: Tool handler implementation patterns
globs: ["src/tools/**/*.ts"]
alwaysApply: false
---

# Tool Handler Patterns

## Tool Handler Signature

All tool handlers follow this consistent signature:

```typescript
import { ExecutorContext, ToolResult } from '../core/types';
import { makeError, makeDebug } from '../core';

export function handleToolName(args: ToolNameArgs, context: ExecutorContext): ToolResult {
    const { start } = context;
    
    // Implementation...
    
    return {
        ok: true,
        result: { /* structured result */ },
        error: null,
        _debug: makeDebug({ 
            path: 'tool_json', 
            start, 
            model: null, 
            memory_read: false, 
            memory_write: false 
        }),
    };
}
```

## ExecutorContext Usage

Extract only what you need from context:

```typescript
export function handleRecall(args: RecallArgs, context: ExecutorContext): ToolResult {
    // Destructure needed properties
    const { 
        readMemory, 
        memoryPath, 
        memoryLimit, 
        scoreEntry, 
        sortByScoreAndRecency, 
        start 
    } = context;
    
    // Use context methods for storage operations
    const entries = readMemory(memoryPath).entries;
    
    // Use context helpers for scoring/sorting
    const matches = sortByScoreAndRecency(entries, needle, terms);
}
```

## Error Handling Pattern

Always return structured errors, never throw:

```typescript
export function handleFileOp(args: FileArgs, context: ExecutorContext): ToolResult {
    const { paths, start } = context;
    
    // Use capability API for path validation
    let resolvedPath: string;
    try {
        resolvedPath = paths.resolveAllowed(args.path, 'read');
    } catch (err: any) {
        return {
            ok: false,
            result: null,
            error: err,  // Already a ToolError from capability API
            _debug: makeDebug({ path: 'tool_json', start, model: null, memory_read: false, memory_write: false }),
        };
    }
    
    // File operations in try-catch
    try {
        const content = fs.readFileSync(resolvedPath, 'utf8');
        return { ok: true, result: { content }, error: null, _debug: /* ... */ };
    } catch (err: any) {
        return {
            ok: false,
            result: null,
            error: makeError('EXEC_ERROR', `Failed to read file: ${err.message}`),
            _debug: makeDebug({ path: 'tool_json', start, model: null, memory_read: false, memory_write: false }),
        };
    }
}
```

## Capability-Based APIs

Use context capabilities instead of raw operations:

```typescript
// Path operations - use context.paths
const resolved = context.paths.resolve(requestedPath);
context.paths.assertAllowed(resolved, 'write');
const safePath = context.paths.resolveAllowed(requestedPath, 'read');

// Command execution - use context.commands
const result = context.commands.runAllowed(cmd, args);

// Storage operations - use context methods
context.readJsonl<Task>(tasksPath, isValidTask);
context.writeJsonl(tasksPath, tasks);
context.appendJsonl(memoryLogPath, entry);
```

## Debug Info

Always include `_debug` with accurate flags:

```typescript
_debug: makeDebug({
    path: 'tool_json',           // Routing path that led here
    start,                        // Start timestamp from context
    model: null,                  // LLM model if used, null otherwise
    memory_read: true,            // Did this tool read from memory?
    memory_write: true,           // Did this tool write to memory?
}),
```

## Zod Schema Registration

Register schemas in `src/core/types.ts`:

```typescript
// 1. Define schema with validation rules
export const MyToolSchema = z.object({
    text: z.string().min(1),
    limit: z.number().int().min(1).max(100).optional(),
});

// 2. Derive type
export type MyToolArgs = z.infer<typeof MyToolSchema>;

// 3. Add to ToolSchemas registry
export const ToolSchemas: Record<string, z.ZodTypeAny> = {
    // ... existing tools
    my_tool: MyToolSchema,
};
```

## Tool Status

Mark tool readiness in ToolSpec:

```typescript
const TOOL_SPEC: ToolSpec = {
    status: 'ready',        // 'ready' | 'stub' | 'experimental'
    description: 'Does something useful',
    required: ['text'],
    parameters: {
        text: { type: 'string', description: 'Input text' },
    },
};
```

## Adding a New Tool - Checklist

When adding a new tool, complete ALL steps:

### 1. Define Schema (`src/core/types.ts`)
```typescript
export const MyNewToolSchema = z.object({
    input: z.string().min(1),
    option: z.boolean().optional(),
});
export type MyNewToolArgs = z.infer<typeof MyNewToolSchema>;

// Add to ToolSchemas map
export const ToolSchemas = {
    // ...existing
    my_new_tool: MyNewToolSchema,
};
```

### 2. Create Handler (`src/tools/my_tools.ts`)
```typescript
export function handleMyNewTool(args: MyNewToolArgs, context: ExecutorContext): ToolResult {
    // Implementation
}
```

### 3. Register Handler (`src/core/tool_registry.ts`)
```typescript
import { handleMyNewTool } from '../tools/my_tools';

handlers.set('my_new_tool', handleMyNewTool);
schemas.set('my_new_tool', MyNewToolSchema);
```

### 4. Add to Agent Toolsets (`src/agents/index.ts`)
```typescript
// Add to relevant agents
const ASSISTANT_TOOLS = [...existing, 'my_new_tool'];
```

### 5. Add Router Pattern (optional, `src/app/router.ts`)
```typescript
// If tool has a natural language pattern
const RE_MY_TOOL = /^my command:\s+(.+)$/i;
```

### 6. Write Tests (`src/tools/my_tools.test.ts`)
```typescript
// Test success case
// Test validation errors
// Test permission denied
```

### 7. Update Documentation
- Add to tool list in README if user-facing
- Add to agent descriptions if relevant

## Async Tool Handlers

Some tools need async operations (network, file I/O):

```typescript
export async function handleFetch(
    args: FetchArgs, 
    context: ExecutorContext
): Promise<ToolResult> {
    const { start } = context;
    
    try {
        const response = await fetch(args.url);
        const data = await response.text();
        
        return {
            ok: true,
            result: { content: data, status: response.status },
            error: null,
            _debug: makeDebug({ path: 'tool_json', start, model: null, memory_read: false, memory_write: false }),
        };
    } catch (err: any) {
        return {
            ok: false,
            result: null,
            error: makeError('EXEC_ERROR', `Fetch failed: ${err.message}`),
            _debug: makeDebug({ path: 'tool_json', start, model: null, memory_read: false, memory_write: false }),
        };
    }
}
```

The Executor handles both sync and async handlers:
```typescript
const result = await Promise.resolve(handler(validatedArgs, context));
```

## Related Rules

- **Error Handling**: See `.cursor/rules/errors.mdc` for error patterns in tool handlers
- **Security**: See `.cursor/rules/security.mdc` for security review checklist
- **Performance**: See `.cursor/rules/performance.mdc` for optimization patterns
- **Code Review**: See `.cursor/rules/code_review.mdc` for review checklist
