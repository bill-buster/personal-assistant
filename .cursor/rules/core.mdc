---
description: Core conventions and architecture patterns for the Personal Assistant codebase
globs: ["**/*.ts"]
alwaysApply: true
---

# Personal Assistant - Core Conventions

## Project Overview

This is a local-first CLI assistant that routes natural language to tools with optional LLM fallback. It uses a multi-stage routing strategy: Regex → Heuristic → Parsers → LLM.

## Technology Stack

- **Runtime**: Node.js 18+ with TypeScript (ES2020 target, CommonJS modules)
- **Validation**: Zod v4 for runtime validation at all boundaries
- **Build**: tsc with strict mode enabled
- **Testing**: Custom test runner with colocated test files (`*.test.ts`)

## Architecture Layers

```
src/
├── app/         # Entry points: CLI, REPL, router, web server
├── core/        # Config, executor, types, validation, tool registry
├── agents/      # Agent definitions with role-based tool access
├── parsers/     # Heuristic, task, memory parsers (NLP patterns)
├── providers/   # LLM provider adapters (Groq, OpenRouter)
├── llm/         # ChatModel interface (provider-agnostic)
├── embeddings/  # EmbeddingModel interface
├── storage/     # JSONL persistence, memory store
├── runtime/     # Composition root, bootstrap
└── tools/       # Tool implementations
```

## Import Conventions

```typescript
// 1. Node built-ins with 'node:' prefix
import * as fs from 'node:fs';
import * as path from 'node:path';
import { spawnSync } from 'node:child_process';

// 2. External packages
import { z } from 'zod';

// 3. Internal imports (relative paths only, no @repo/* aliases)
import { ExecutorContext, ToolResult } from '../core/types';
import { makeError, makeDebug } from '../core';
```

## Type Patterns

### Use Zod Schemas for Validation

**Always use Zod v4 for runtime validation at all boundaries.**

#### Basic Schema Patterns

```typescript
// Define schema
export const TaskAddSchema = z.object({
    text: z.string().min(1),
    due: z.string().optional(),
    priority: z.enum(['low', 'medium', 'high']).optional(),
});

// Derive type from schema
export type TaskAddArgs = z.infer<typeof TaskAddSchema>;
```

#### Common Zod Patterns Used in This Project

```typescript
// String with validation
z.string().min(1)                    // Required non-empty string
z.string().optional()                // Optional string
z.string().default('')                // String with default value

// Numbers
z.number().int().min(0)              // Non-negative integer
z.number().int().min(1).max(100)      // Bounded integer
z.number().optional().default(0)      // Optional with default

// Arrays
z.array(z.string()).default([])      // Array with default empty
z.array(z.string()).min(1)            // Non-empty array

// Enums
z.enum(['low', 'medium', 'high'])     // String enum
z.enum(['low', 'medium', 'high']).optional()  // Optional enum

// Complex objects
z.object({
    required: z.string().min(1),
    optional: z.string().optional(),
    withDefault: z.number().default(0),
    nested: z.object({
        field: z.string(),
    }).optional(),
});
```

#### Validation with safeParse

```typescript
// Always use safeParse for validation (never throw)
const result = schema.safeParse(data);

if (!result.success) {
    return {
        ok: false,
        error: makeError('VALIDATION_ERROR', result.error.issues[0].message),
    };
}

// Use result.data (validated and typed)
const validated = result.data;
```

#### Register Schema in ToolSchemas

```typescript
// After defining schema, add to registry
export const ToolSchemas: Record<string, z.ZodTypeAny> = {
    // ... existing tools
    my_tool: MyToolSchema,
};
```

### Use Discriminated Unions for Results

```typescript
export type RouteResult =
    | RouteError
    | RouteToolCall
    | RouteReply;

// With type guards
export function isRouteError(result: RouteResult): result is RouteError {
    return 'error' in result;
}
```

### TypeScript Patterns

#### Discriminated Unions (Preferred Pattern)

```typescript
// Use discriminated unions for result types
export type ToolResult =
    | { ok: true; result: any; _debug?: DebugInfo | null }
    | { ok: false; error: ToolError; _debug?: DebugInfo | null };

// Type guards for runtime checks
export function isSuccess(result: ToolResult): result is { ok: true; result: any } {
    return result.ok === true;
}
```

#### Utility Types

```typescript
// Readonly for immutable data
export type Limits = Readonly<{
    maxReadSize: number;
    maxWriteSize: number;
}>;

// Optional fields
export interface Task {
    id: number;
    text: string;
    done_at?: string | null;  // Optional, can be null
    priority?: 'low' | 'medium' | 'high' | null;
}

// Record types for maps
export const ToolSchemas: Record<string, z.ZodTypeAny> = {
    // ...
};
```

#### Type Inference from Zod

```typescript
// Always derive types from Zod schemas
export const MySchema = z.object({ /* ... */ });
export type MyType = z.infer<typeof MySchema>;  // ✅ Preferred

// Not: manually defining types that duplicate schema
// type MyType = { /* ... */ };  // ❌ Avoid duplication
```

### Structured Error Objects

```typescript
export interface ToolError {
    code: string;    // e.g., 'EXEC_ERROR', 'VALIDATION_ERROR'
    message: string;
    details?: any;
}

// Create errors with makeError helper
return {
    ok: false,
    error: makeError('EXEC_ERROR', `Failed to read file: ${err.message}`),
};
```

## Function Documentation

Use JSDoc for all exported functions:

```typescript
/**
 * Handle remember tool.
 * @param args - Tool arguments containing text.
 * @param context - Execution context.
 * @returns Result object with ok, result, error, debug.
 */
export function handleRemember(args: RememberArgs, context: ExecutorContext): ToolResult {
    // ...
}
```

## Code Style

- Use `const` by default, `let` only when reassignment needed
- Prefer early returns to reduce nesting
- Use optional chaining (`?.`) and nullish coalescing (`??`)
- Prefix unused parameters with underscore: `(_unused, used) => {}`
- Empty catch blocks are allowed: `catch { }`
- Console logging is allowed (no-console: off)

## File Naming

- Source files: `snake_case.ts` (e.g., `memory_tools.ts`, `tool_registry.ts`)
- Test files: `*.test.ts` colocated with source
- Index files: `index.ts` for barrel exports

## Async Patterns

Always use async/await, never raw Promises:

```typescript
// ✅ Good
async function fetchData(): Promise<Data> {
    const result = await provider.complete(prompt);
    return result.data;
}

// ❌ Bad - raw Promise chains
function fetchData(): Promise<Data> {
    return provider.complete(prompt).then(r => r.data);
}
```

Handle async errors with try/catch:

```typescript
async function safeOperation(): Promise<ToolResult> {
    try {
        const data = await riskyAsyncCall();
        return { ok: true, result: data };
    } catch (err: any) {
        return { ok: false, error: makeError('EXEC_ERROR', err.message) };
    }
}
```

## Configuration Priority

Environment variables override config files:

```typescript
// Priority order (highest to lowest):
// 1. Environment variables (GROQ_API_KEY, ASSISTANT_DATA_DIR)
// 2. Config file (~/.assistant/config.json)
// 3. Hardcoded defaults

const apiKey = process.env.GROQ_API_KEY || config.apiKeys?.groq || null;
```

## Logging Conventions

Use console methods directly (no-console is off):

```typescript
// Verbose/debug output (only when --verbose flag)
if (verbose) console.log('[Verbose] Processing:', input);

// Errors always go to stderr
console.error('[Error] Failed to connect:', err.message);

// Prefix with context for traceability
console.log(`[Router] Matched tool: ${toolName}`);
console.log(`[Executor] Running: ${toolName}`);
```

## Common Helpers

Use helpers from `src/core/`:

```typescript
import { 
    makeError,      // Create structured ToolError
    makeDebug,      // Create DebugInfo object
    nowMs,          // Current timestamp in ms
    makeToolCall,   // Create ToolCall object
    parseArgs,      // Parse CLI arguments
} from '../core';
```

## Handling Stuck Operations

**If a command or file read seems stuck:**

1. **Check timeouts**: Most operations have built-in timeouts (git: 10s, LLM: 60s, fetch: 6s)
2. **If command hangs**: Check with `ps aux | grep <command>` or add `timeout` wrapper
3. **If file read fails**: Check existence (`ls`), permissions (`stat`), or try `cat` command
4. **If no response**: Check exit code (`echo $?`), check stderr, verify command isn't waiting for input

**When to give up:**
- Operation timed out 3+ times
- Permission denied (may need user intervention)
- Error unclear after 2-3 attempts

**See `.cursor/rules/debugging.mdc` for detailed troubleshooting patterns.**

## Related Rules

- **Error Handling**: See `.cursor/rules/errors.mdc` for error patterns and error codes
- **Performance**: See `.cursor/rules/performance.mdc` for optimization patterns
- **Security**: See `.cursor/rules/security.mdc` for security patterns
- **Tools**: See `.cursor/rules/tools.mdc` for tool implementation patterns
- **Test Policy**: See `.cursor/rules/test_policy.mdc` for when to run tests
- **Testing**: See `.cursor/rules/testing.mdc` for test-writing patterns
- **Research Policy**: See `.cursor/rules/research_policy.mdc` for when to use web research vs codebase knowledge
