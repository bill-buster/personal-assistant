---
description: Performance optimization patterns and best practices
globs: ["**/*.ts"]
alwaysApply: false
---

# Performance Patterns

## Caching Strategy

Use caching to avoid redundant work:

```typescript
// ✅ Good - Cache expensive operations
const cache = new FileCache<ExpensiveResult>();
const cacheKey = createCacheKey(inputs);

const cached = cache.get(cacheKey);
if (cached) return cached;

const result = await expensiveOperation();
cache.set(cacheKey, result);
return result;
```

### Cache Key Design

Cache keys should include all inputs that affect the result:

```typescript
// ✅ Good - Includes all relevant inputs
function createCacheKey(
    prompt: string,
    tools: Record<string, ToolSpec>,
    history: Message[],
    systemPrompt?: string
): string {
    return hash(
        prompt,
        JSON.stringify(tools), // Sorted keys for consistency
        JSON.stringify(history.slice(-3)), // Last 3 messages only
        systemPrompt || ''
    );
}

// ❌ Bad - Missing inputs
function createCacheKey(prompt: string): string {
    return hash(prompt); // Missing tools, history, system prompt
}
```

## Lazy Evaluation

Defer expensive operations until needed:

```typescript
// ✅ Good - Lazy initialization
class LazyProvider {
    private _provider: LLMProvider | null = null;
    
    get provider(): LLMProvider {
        if (!this._provider) {
            this._provider = createProvider(this.config);
        }
        return this._provider;
    }
}

// ❌ Bad - Eager initialization
class EagerProvider {
    private provider = createProvider(this.config); // Created even if never used
}
```

## Batch Operations

Group multiple operations when possible:

```typescript
// ✅ Good - Batch reads
const allFiles = await Promise.all(
    filePaths.map(path => readFile(path))
);

// ❌ Bad - Sequential reads
for (const path of filePaths) {
    await readFile(path); // Slow - one at a time
}
```

## Pre-compiled Patterns

Pre-compile regex patterns at module level for V8 optimization:

```typescript
// ✅ Good - Module-level regex (compiled once)
const RE_REMEMBER = /^remember:\s+([\s\S]+)$/i;

export function parse(input: string) {
    const match = input.match(RE_REMEMBER);
    // ...
}

// ❌ Bad - Compiled on every call
export function parse(input: string) {
    const match = input.match(/^remember:\s+([\s\S]+)$/i); // Recompiled each time
}
```

## Early Returns

Exit early to avoid unnecessary work:

```typescript
// ✅ Good - Early returns
export function process(input: string): Result {
    if (!input) return { ok: false, error: 'Empty input' };
    if (input.length > MAX_LENGTH) return { ok: false, error: 'Too long' };
    
    // Only process valid input
    return expensiveOperation(input);
}

// ❌ Bad - Nested conditions
export function process(input: string): Result {
    if (input) {
        if (input.length <= MAX_LENGTH) {
            return expensiveOperation(input);
        } else {
            return { ok: false, error: 'Too long' };
        }
    } else {
        return { ok: false, error: 'Empty input' };
    }
}
```

## Streaming for Large Data

Use streaming for large responses:

```typescript
// ✅ Good - Stream large responses
async function* streamLargeData(): AsyncGenerator<Chunk> {
    for (const chunk of data) {
        yield chunk;
    }
}

// ❌ Bad - Load everything into memory
async function loadLargeData(): Promise<Data[]> {
    return allData; // May exhaust memory
}
```

## Parallel Execution

Run independent operations in parallel:

```typescript
// ✅ Good - Parallel execution
const results = await Promise.all([
    fetchData1(),
    fetchData2(),
    fetchData3(),
]);

// ❌ Bad - Sequential execution
const result1 = await fetchData1();
const result2 = await fetchData2();
const result3 = await fetchData3();
```

## Memory Management

Avoid memory leaks:

```typescript
// ✅ Good - Clean up resources
class ResourceManager {
    private resources: Set<Resource> = new Set();
    
    add(resource: Resource) {
        this.resources.add(resource);
    }
    
    cleanup() {
        for (const resource of this.resources) {
            resource.close();
        }
        this.resources.clear();
    }
}

// ❌ Bad - Resources never cleaned up
class ResourceManager {
    private resources: Resource[] = [];
    
    add(resource: Resource) {
        this.resources.push(resource); // Never cleaned up
    }
}
```

## Performance Monitoring

Add timing for performance-critical paths:

```typescript
// ✅ Good - Track performance
const start = Date.now();
const result = await expensiveOperation();
const duration = Date.now() - start;

if (duration > 1000) {
    console.warn(`[Perf] Slow operation: ${duration}ms`);
}

// Include in debug info
return {
    ok: true,
    result,
    _debug: makeDebug({
        path: 'tool_json',
        start,
        duration_ms: duration,
        // ...
    }),
};
```

## Database/Storage Optimization

For JSONL storage:

```typescript
// ✅ Good - Append-only for logs
function appendLog(entry: LogEntry): void {
    const line = JSON.stringify(entry) + '\n';
    fs.appendFileSync(logPath, line); // Fast append
}

// ✅ Good - Atomic writes for updates
function updateTasks(tasks: Task[]): void {
    const tmpPath = tasksPath + '.tmp';
    fs.writeFileSync(tmpPath, serialize(tasks));
    fs.renameSync(tmpPath, tasksPath); // Atomic on POSIX
}

// ❌ Bad - Read entire file for append
function appendLog(entry: LogEntry): void {
    const all = readAllLogs();
    all.push(entry);
    writeAllLogs(all); // Slow - rewrites entire file
}
```

## Avoid Premature Optimization

Optimize only when needed:

```typescript
// ✅ Good - Simple and clear
function findTask(id: number): Task | null {
    return tasks.find(t => t.id === id) || null;
}

// ❌ Bad - Over-engineered
function findTask(id: number): Task | null {
    // Complex indexing system for 10 items - unnecessary
    const index = buildIndex(tasks);
    return index.get(id) || null;
}
```

## Performance Checklist

Before optimizing, verify:

- [ ] Is this actually a bottleneck? (Profile first)
- [ ] Will optimization improve user experience?
- [ ] Does optimization maintain code clarity?
- [ ] Is caching appropriate? (Consider invalidation)
- [ ] Can operations be parallelized?
- [ ] Are resources cleaned up properly?

## Common Performance Pitfalls

### ❌ Don't Do This

```typescript
// Synchronous operations in async context
const data = fs.readFileSync(largeFile); // Blocks event loop

// Unnecessary array operations
const filtered = array.filter(x => x).map(x => x.value).filter(x => x > 0);
// Better: Single pass with reduce

// Creating objects in hot loops
for (let i = 0; i < 1000000; i++) {
    const obj = { value: i }; // Creates many objects
}

// Not using streaming for large data
const all = await fetchAll(); // May exhaust memory
```

### ✅ Do This Instead

```typescript
// Async file operations
const data = await fs.promises.readFile(largeFile);

// Single-pass operations
const filtered = array.reduce((acc, x) => {
    if (x && x.value > 0) acc.push(x.value);
    return acc;
}, []);

// Reuse objects or use primitives
let value = 0;
for (let i = 0; i < 1000000; i++) {
    value = i; // Primitive, no allocation
}

// Stream large data
for await (const chunk of streamLargeData()) {
    process(chunk);
}
```

## Integration with Other Rules

- **Caching Rule**: See `docs/CACHING.md` for cache implementation details
- **Storage Rule**: See `.cursor/rules/storage.mdc` for JSONL optimization
- **Testing Rule**: See `.cursor/rules/testing.mdc` for test performance (parallel execution)
