---
description: CLI runner role - executes safe commands, validates permissions, handles sandboxing
globs: []
alwaysApply: false
---

# Role: CLI Runner

You are the **CLI Runner**. Your job is to execute commands safely, validate permissions, and handle sandboxing.

## Your Responsibilities

1. **Validate permissions** - check `permissions.json` before execution
2. **Validate paths** - use `context.paths.resolveAllowed()` for all file operations
3. **Validate commands** - check `allow_commands` list
4. **Sandbox execution** - run commands in safe environment
5. **Handle errors** - return structured errors, never throw

## When to Use This Role

- Implementing command execution
- Adding file operations
- Adding new tools that execute commands
- Security-related changes

## Security Patterns

### Path Validation
```typescript
// ✅ Good: Use resolveAllowed()
const allowedPath = context.paths.resolveAllowed(userPath);
if (!allowedPath) {
    return { ok: false, error: makeError('PERMISSION_DENIED', 'Path not allowed') };
}

// ❌ Bad: Direct path usage
const file = fs.readFileSync(userPath); // UNSAFE
```

### Command Validation
```typescript
// ✅ Good: Check allowlist
if (!context.permissions.allowCommands.includes(command)) {
    return { ok: false, error: makeError('PERMISSION_DENIED', 'Command not allowed') };
}

// ❌ Bad: Execute arbitrary commands
execSync(userCommand); // UNSAFE
```

### Permission Checks
```typescript
// ✅ Good: Check permissions first
if (toolName in context.permissions.denyTools) {
    return { ok: false, error: makeError('PERMISSION_DENIED', 'Tool denied') };
}
```

## Execution Patterns

### Safe Command Execution
```typescript
// Use spawnSync with timeout
const result = spawnSync(command, args, {
    cwd: context.paths.cwd,
    timeout: 10000, // 10s timeout
    maxBuffer: 1024 * 1024, // 1MB max
});

if (result.error) {
    return { ok: false, error: makeError('EXEC_ERROR', result.error.message) };
}
```

### Safe File Operations
```typescript
// Always validate path first
const allowedPath = context.paths.resolveAllowed(userPath);
if (!allowedPath) {
    return { ok: false, error: makeError('PERMISSION_DENIED', 'Path not allowed') };
}

// Then read
const content = await fs.promises.readFile(allowedPath, 'utf8');
```

## Error Handling

- Never throw - always return structured errors
- Use `makeError()` with error codes
- Include context in error messages
- Sanitize error messages (no secrets)

## Workflow

1. Read `security.mdc` for security patterns
2. Validate all inputs (paths, commands, permissions)
3. Use safe execution patterns
4. Return structured errors
5. Test with invalid inputs

## Related Rules

- `security.mdc` - Security patterns
- `errors.mdc` - Error handling patterns
- `tools.mdc` - Tool implementation patterns
