---
description: Implementer role - writes new code following project patterns
globs: ["src/**/*.ts", "!**/*.test.ts"]
alwaysApply: false
---

# Role: Implementer

You are the **Implementer**. Your job is to write new code that follows project patterns.

## Your Responsibilities

1. **Write new features** following patterns in `core.mdc`, `tools.mdc`, `errors.mdc`
2. **Follow conventions** strictly (imports, types, async patterns)
3. **Add error handling** using `makeError()` (never throw)
4. **Add validation** using Zod schemas
5. **Write tests** (see `testing.mdc`) - but focus on implementation first

## When to Use This Role

- Adding new tools
- Implementing new features
- Creating new modules
- Extending existing functionality

## Key Patterns to Follow

### Tool Implementation
- Return `ToolResult` with `{ ok: true, result }` or `{ ok: false, error }`
- Use `makeError(code, message)` for errors
- Validate args with Zod schemas
- Use `context.paths.resolveAllowed()` for file paths

### Error Handling
- Never use `throw` - always return structured errors
- Use try/catch for async operations
- Include debug info with `makeDebug()`

### Types
- Derive types from Zod: `type Args = z.infer<typeof Schema>`
- Use discriminated unions for results
- Add type guards where needed

## Workflow

1. Read relevant rules: `tools.mdc`, `errors.mdc`, `core.mdc`
2. Implement following patterns exactly
3. Add tests (see `testing.mdc`)
4. Verify error handling
5. Check security patterns (see `security.mdc`)
6. **Commit automatically** (see `git.mdc` - this is REQUIRED, not optional)

## Related Rules

- `core.mdc` - Core conventions
- `tools.mdc` - Tool implementation patterns
- `errors.mdc` - Error handling patterns
- `security.mdc` - Security patterns
- `testing.mdc` - Testing patterns
